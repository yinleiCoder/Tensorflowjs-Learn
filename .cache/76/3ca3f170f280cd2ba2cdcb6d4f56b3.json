{"id":"../node_modules/@tensorflow/tfjs-vis/dist/render/confusion_matrix.js","dependencies":[{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\confusion_matrix.js.map","includedInParent":true,"mtime":1595569813578},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\package.json","includedInParent":true,"mtime":1595925880834},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\package.json","includedInParent":true,"mtime":1595569813578},{"name":"vega-embed","loc":{"line":30,"column":45},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\confusion_matrix.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\vega-embed\\build\\src\\embed.js"},{"name":"../util/dom","loc":{"line":31,"column":22},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\confusion_matrix.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\dom.js"},{"name":"./render_utils","loc":{"line":32,"column":31},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\confusion_matrix.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\render_utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\nconst dom_1 = require(\"../util/dom\");\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a confusion matrix.\n *\n * Can optionally exclude the diagonal from being shaded if one wants the visual\n * focus to be on the incorrect classifications. Note that if the classification\n * is perfect (i.e. only the diagonal has values) then the diagonal will always\n * be shaded.\n *\n * ```js\n * const rows = 5;\n * const cols = 5;\n * const values = [];\n * for (let i = 0; i < rows; i++) {\n *   const row = []\n *   for (let j = 0; j < cols; j++) {\n *     row.push(Math.round(Math.random() * 50));\n *   }\n *   values.push(row);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Confusion Matrix', tab: 'Charts' };\n * tfvis.render.confusionMatrix(surface, data);\n * ```\n *\n * ```js\n * // The diagonal can be excluded from shading.\n *\n * const data = {\n *   values: [[4, 2, 8], [1, 7, 2], [3, 3, 20]],\n * }\n *\n * // Render to visor\n * const surface = {\n *  name: 'Confusion Matrix with Excluded Diagonal', tab: 'Charts'\n * };\n *\n * tfvis.render.confusionMatrix(surface, data, {\n *   shadeDiagonal: false\n * });\n * ```\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nfunction confusionMatrix(container, data, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const options = Object.assign({}, defaultOpts, opts);\n        const drawArea = render_utils_1.getDrawArea(container);\n        // Format data for vega spec; an array of objects, one for for each cell\n        // in the matrix.\n        const values = [];\n        const inputArray = data.values;\n        const tickLabels = data.tickLabels || [];\n        const generateLabels = tickLabels.length === 0;\n        let nonDiagonalIsAllZeroes = true;\n        for (let i = 0; i < inputArray.length; i++) {\n            const label = generateLabels ? `Class ${i}` : tickLabels[i];\n            if (generateLabels) {\n                tickLabels.push(label);\n            }\n            for (let j = 0; j < inputArray[i].length; j++) {\n                const prediction = generateLabels ? `Class ${j}` : tickLabels[j];\n                const count = inputArray[i][j];\n                if (i === j && !options.shadeDiagonal) {\n                    values.push({\n                        label,\n                        prediction,\n                        count,\n                        noFill: true,\n                    });\n                }\n                else {\n                    values.push({\n                        label,\n                        prediction,\n                        count,\n                        scaleCount: count,\n                    });\n                    // When not shading the diagonal we want to check if there is a non\n                    // zero value. If all values are zero we will not color them as the\n                    // scale will be invalid.\n                    if (count !== 0) {\n                        nonDiagonalIsAllZeroes = false;\n                    }\n                }\n            }\n        }\n        if (!options.shadeDiagonal && nonDiagonalIsAllZeroes) {\n            // User has specified requested not to shade the diagonal but all the other\n            // values are zero. We have two choices, don't shade the anything or only\n            // shade the diagonal. We choose to shade the diagonal as that is likely\n            // more helpful even if it is not what the user specified.\n            for (const val of values) {\n                if (val.noFill === true) {\n                    val.noFill = false;\n                    val.scaleCount = val.count;\n                }\n            }\n        }\n        const embedOpts = {\n            actions: false,\n            mode: 'vega-lite',\n            defaultStyle: false,\n        };\n        //@ts-ignore\n        const spec = {\n            'width': options.width || dom_1.getDefaultWidth(drawArea),\n            'height': options.height || dom_1.getDefaultHeight(drawArea),\n            'padding': 0,\n            'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true,\n            },\n            'config': {\n                'axis': {\n                    'labelFontSize': options.fontSize,\n                    'titleFontSize': options.fontSize,\n                },\n                'text': { 'fontSize': options.fontSize },\n                'legend': {\n                    'labelFontSize': options.fontSize,\n                    'titleFontSize': options.fontSize,\n                }\n            },\n            //@ts-ignore\n            'data': { 'values': values },\n            'encoding': {\n                'x': {\n                    'field': 'prediction',\n                    'type': 'ordinal',\n                    'title': options.xLabel || 'prediction',\n                    // Maintain sort order of the axis if labels is passed in\n                    'scale': { 'domain': tickLabels },\n                },\n                'y': {\n                    'field': 'label',\n                    'type': 'ordinal',\n                    'title': options.yLabel || 'label',\n                    // Maintain sort order of the axis if labels is passed in\n                    'scale': { 'domain': tickLabels },\n                },\n            },\n            'layer': [\n                {\n                    // The matrix\n                    'transform': [\n                        { 'filter': 'datum.noFill != true' },\n                    ],\n                    'mark': {\n                        'type': 'rect',\n                    },\n                    'encoding': {\n                        'color': {\n                            'field': 'scaleCount',\n                            'type': 'quantitative',\n                            //@ts-ignore\n                            'scale': { 'range': options.colorMap },\n                        },\n                        'tooltip': [\n                            { 'field': 'label', 'type': 'nominal' },\n                            { 'field': 'prediction', 'type': 'nominal' },\n                            { 'field': 'count', 'type': 'quantitative' },\n                        ]\n                    },\n                },\n            ]\n        };\n        if (options.shadeDiagonal === false) {\n            //@ts-ignore\n            spec.layer.push({\n                // render unfilled rects for the diagonal\n                'transform': [\n                    { 'filter': 'datum.noFill == true' },\n                ],\n                'mark': {\n                    'type': 'rect',\n                    'fill': 'white',\n                },\n                'encoding': {\n                    'tooltip': [\n                        { 'field': 'label', 'type': 'nominal' },\n                        { 'field': 'prediction', 'type': 'nominal' },\n                        { 'field': 'count', 'type': 'quantitative' },\n                    ]\n                },\n            });\n        }\n        if (options.showTextOverlay) {\n            //@ts-ignore\n            spec.layer.push({\n                // The text labels\n                'mark': { 'type': 'text', 'baseline': 'middle' },\n                'encoding': {\n                    'text': {\n                        'field': 'count',\n                        'type': 'nominal',\n                    },\n                }\n            });\n        }\n        const colorMap = typeof options.colorMap === 'string' ?\n            { scheme: options.colorMap } :\n            options.colorMap;\n        //@ts-ignore\n        spec.layer[0].encoding.color.scale.range = colorMap;\n        yield vega_embed_1.default(drawArea, spec, embedOpts);\n    });\n}\nexports.confusionMatrix = confusionMatrix;\nconst defaultOpts = {\n    xLabel: null,\n    yLabel: null,\n    xType: 'nominal',\n    yType: 'nominal',\n    shadeDiagonal: true,\n    fontSize: 12,\n    showTextOverlay: true,\n    height: 400,\n    colorMap: ['#f7fbff', '#4292c6'],\n};\n"},"sourceMaps":{"js":{"version":3,"file":"confusion_matrix.js","sourceRoot":"","sources":["../../src/render/confusion_matrix.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {ConfusionMatrixData, ConfusionMatrixOptions, Drawable,} from '../types';\nimport {getDefaultHeight, getDefaultWidth} from '../util/dom';\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a confusion matrix.\n *\n * Can optionally exclude the diagonal from being shaded if one wants the visual\n * focus to be on the incorrect classifications. Note that if the classification\n * is perfect (i.e. only the diagonal has values) then the diagonal will always\n * be shaded.\n *\n * ```js\n * const rows = 5;\n * const cols = 5;\n * const values = [];\n * for (let i = 0; i < rows; i++) {\n *   const row = []\n *   for (let j = 0; j < cols; j++) {\n *     row.push(Math.round(Math.random() * 50));\n *   }\n *   values.push(row);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Confusion Matrix', tab: 'Charts' };\n * tfvis.render.confusionMatrix(surface, data);\n * ```\n *\n * ```js\n * // The diagonal can be excluded from shading.\n *\n * const data = {\n *   values: [[4, 2, 8], [1, 7, 2], [3, 3, 20]],\n * }\n *\n * // Render to visor\n * const surface = {\n *  name: 'Confusion Matrix with Excluded Diagonal', tab: 'Charts'\n * };\n *\n * tfvis.render.confusionMatrix(surface, data, {\n *   shadeDiagonal: false\n * });\n * ```\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function confusionMatrix(\n    container: Drawable, data: ConfusionMatrixData,\n    opts: ConfusionMatrixOptions = {}): Promise<void> {\n  const options = Object.assign({}, defaultOpts, opts);\n  const drawArea = getDrawArea(container);\n\n  // Format data for vega spec; an array of objects, one for for each cell\n  // in the matrix.\n  const values: MatrixEntry[] = [];\n\n  const inputArray = data.values;\n  const tickLabels = data.tickLabels || [];\n  const generateLabels = tickLabels.length === 0;\n\n  let nonDiagonalIsAllZeroes = true;\n  for (let i = 0; i < inputArray.length; i++) {\n    const label = generateLabels ? `Class ${i}` : tickLabels[i];\n\n    if (generateLabels) {\n      tickLabels.push(label);\n    }\n\n    for (let j = 0; j < inputArray[i].length; j++) {\n      const prediction = generateLabels ? `Class ${j}` : tickLabels[j];\n\n      const count = inputArray[i][j];\n      if (i === j && !options.shadeDiagonal) {\n        values.push({\n          label,\n          prediction,\n          count,\n          noFill: true,\n        });\n      } else {\n        values.push({\n          label,\n          prediction,\n          count,\n          scaleCount: count,\n        });\n        // When not shading the diagonal we want to check if there is a non\n        // zero value. If all values are zero we will not color them as the\n        // scale will be invalid.\n        if (count !== 0) {\n          nonDiagonalIsAllZeroes = false;\n        }\n      }\n    }\n  }\n\n  if (!options.shadeDiagonal && nonDiagonalIsAllZeroes) {\n    // User has specified requested not to shade the diagonal but all the other\n    // values are zero. We have two choices, don't shade the anything or only\n    // shade the diagonal. We choose to shade the diagonal as that is likely\n    // more helpful even if it is not what the user specified.\n    for (const val of values) {\n      if (val.noFill === true) {\n        val.noFill = false;\n        val.scaleCount = val.count;\n      }\n    }\n  }\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  //@ts-ignore\n  const spec: VisualizationSpec = {\n    'width': options.width || getDefaultWidth(drawArea),\n    'height': options.height || getDefaultHeight(drawArea),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      }\n    },\n    //@ts-ignore\n    'data': {'values': values},\n    'encoding': {\n      'x': {\n        'field': 'prediction',\n        'type': 'ordinal',\n        'title': options.xLabel || 'prediction',\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': tickLabels},\n      },\n      'y': {\n        'field': 'label',\n        'type': 'ordinal',\n        'title': options.yLabel || 'label',\n        // Maintain sort order of the axis if labels is passed in\n        'scale': {'domain': tickLabels},\n      },\n    },\n    'layer': [\n      {\n        // The matrix\n        'transform': [\n          {'filter': 'datum.noFill != true'},\n        ],\n        'mark': {\n          'type': 'rect',\n        },\n        'encoding': {\n          'color': {\n            'field': 'scaleCount',\n            'type': 'quantitative',\n            //@ts-ignore\n            'scale': {'range': options.colorMap},\n          },\n          'tooltip': [\n            {'field': 'label', 'type': 'nominal'},\n            {'field': 'prediction', 'type': 'nominal'},\n            {'field': 'count', 'type': 'quantitative'},\n          ]\n        },\n      },\n    ]\n  };\n\n  if (options.shadeDiagonal === false) {\n    //@ts-ignore\n    spec.layer.push(\n        {\n          // render unfilled rects for the diagonal\n          'transform': [\n            {'filter': 'datum.noFill == true'},\n          ],\n          'mark': {\n            'type': 'rect',\n            'fill': 'white',\n          },\n          'encoding': {\n            'tooltip': [\n              {'field': 'label', 'type': 'nominal'},\n              {'field': 'prediction', 'type': 'nominal'},\n              {'field': 'count', 'type': 'quantitative'},\n            ]\n          },\n        },\n    );\n  }\n\n  if (options.showTextOverlay) {\n    //@ts-ignore\n    spec.layer.push({\n      // The text labels\n      'mark': {'type': 'text', 'baseline': 'middle'},\n      'encoding': {\n        'text': {\n          'field': 'count',\n          'type': 'nominal',\n        },\n      }\n    });\n  }\n\n  const colorMap = typeof options.colorMap === 'string' ?\n      {scheme: options.colorMap} :\n      options.colorMap;\n  //@ts-ignore\n  spec.layer[0].encoding.color.scale.range = colorMap;\n\n  await embed(drawArea, spec, embedOpts);\n}\n\nconst defaultOpts: ConfusionMatrixOptions = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'nominal',\n  yType: 'nominal',\n  shadeDiagonal: true,\n  fontSize: 12,\n  showTextOverlay: true,\n  height: 400,\n  colorMap: ['#f7fbff', '#4292c6'],\n};\n\ninterface MatrixEntry {\n  label: string;\n  prediction: string;\n  // The displayed count\n  count: number;\n  // The count values used to compute the color scale\n  scaleCount?: number;\n  noFill?: boolean;\n}\n"]}},"error":null,"hash":"e87d0475264284299ac36aa6023bebeb","cacheData":{"env":{}}}