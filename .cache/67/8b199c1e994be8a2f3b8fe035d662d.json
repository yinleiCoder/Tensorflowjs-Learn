{"id":"../node_modules/@tensorflow/tfjs-vis/dist/show/history.js","dependencies":[{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\show\\history.js.map","includedInParent":true,"mtime":1595569813578},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\package.json","includedInParent":true,"mtime":1595925880834},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\package.json","includedInParent":true,"mtime":1595569813578},{"name":"../render/linechart","loc":{"line":27,"column":28},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\show\\history.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\linechart.js"},{"name":"../render/render_utils","loc":{"line":28,"column":31},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\show\\history.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\render_utils.js"},{"name":"../util/dom","loc":{"line":29,"column":22},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\show\\history.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\dom.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst linechart_1 = require(\"../render/linechart\");\nconst render_utils_1 = require(\"../render/render_utils\");\nconst dom_1 = require(\"../util/dom\");\n/**\n * Renders a tf.Model training 'History'.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32\n * });\n *\n * tfvis.show.history(surface, history, ['loss', 'acc']);\n * ```\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history live', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = [];\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: {\n *      onEpochEnd: (epoch, log) => {\n *        history.push(log);\n *        tfvis.show.history(surface, history, ['loss', 'acc']);\n *      }\n *    }\n * });\n * ```\n *\n * @param history A history like object. Either a tfjs-layers `History` object\n *  or an array of tfjs-layers `Logs` objects.\n * @param metrics An array of strings for each metric to plot from the history\n *  object. Using this allows you to control which metrics appear on the same\n *  plot.\n * @param opts Optional parameters for the line charts.\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nfunction history(container, history, metrics, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Get the draw surface\n        const drawArea = render_utils_1.getDrawArea(container);\n        // We organize the data from the history object into discrete plot data\n        // objects so that we can group together appropriate metrics into single\n        // multi-series charts.\n        const plots = {};\n        for (const metric of metrics) {\n            if (!(/val_/.test(metric))) {\n                // Non validation metric\n                const values = getValues(history, metric, metrics.indexOf(metric));\n                initPlot(plots, metric);\n                plots[metric].series.push(metric);\n                plots[metric].values.push(values);\n            }\n            else {\n                // Validation metrics are grouped with their equivalent non validation\n                // metrics. Note that the corresponding non validation metric may not\n                // actually be included but we still want to use it as a plot name.\n                const nonValidationMetric = metric.replace('val_', '');\n                initPlot(plots, nonValidationMetric);\n                const values = getValues(history, metric, metrics.indexOf(metric));\n                plots[nonValidationMetric].series.push(metric);\n                plots[nonValidationMetric].values.push(values);\n            }\n        }\n        // Render each plot specified above to a new subsurface.\n        // A plot may have multiple series.\n        const plotNames = Object.keys(plots);\n        const options = Object.assign({}, { xLabel: 'Iteration', yLabel: 'Value' }, opts);\n        const renderPromises = [];\n        for (const name of plotNames) {\n            const subContainer = dom_1.subSurface(drawArea, name);\n            const series = plots[name].series;\n            const values = plots[name].values;\n            if (series.every(seriesName => Boolean(seriesName.match('acc')))) {\n                // Set a domain of 0-1 if all the series in this plot are related to\n                // accuracy. Can be overridden by setting zoomToFitAccuracy to true.\n                if (options.zoomToFitAccuracy) {\n                    options.zoomToFit = true;\n                }\n                else {\n                    options.yAxisDomain = [0, 1];\n                    delete options.zoomToFit;\n                }\n            }\n            const done = linechart_1.linechart(subContainer, { values, series }, options);\n            renderPromises.push(done);\n        }\n        yield Promise.all(renderPromises);\n    });\n}\nexports.history = history;\nfunction initPlot(plot, name) {\n    if (plot[name] == null) {\n        plot[name] = { series: [], values: [] };\n    }\n}\n/*\n * Extracts a list of Point2D's suitable for plotting from a HistoryLike for\n * a single metric.\n * @param history a HistoryLike object\n * @param metric the metric to extract from the logs\n * @param metricIndex this is needed because the historylike can be a nested\n * list of logs for multiple metrics, this index lets us extract the correct\n * list.\n */\nfunction getValues(history, metric, metricIndex) {\n    if (Array.isArray(history)) {\n        // If we were passed a nested array we want to get the correct list\n        // for this given metric, metrix index gives us this list.\n        const metricHistory = (Array.isArray(history[0]) ? history[metricIndex] : history);\n        const points = [];\n        for (let i = 0; i < metricHistory.length; i++) {\n            const log = metricHistory[i];\n            points.push({ x: i, y: log[metric] });\n        }\n        return points;\n    }\n    else {\n        return history.history[metric].map((y, x) => ({ x, y }));\n    }\n}\n/**\n * Returns a collection of callbacks to pass to tf.Model.fit. Callbacks are\n * returned for the following events, `onBatchEnd` & `onEpochEnd`.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.fitCallbacks', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: tfvis.show.fitCallbacks(surface, ['loss', 'acc']),\n * });\n * ```\n *\n * @param metrics List of metrics to plot.\n * @param opts Optional parameters\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nfunction fitCallbacks(container, metrics, opts = {}) {\n    const accumulators = {};\n    const callbackNames = opts.callbacks || ['onEpochEnd', 'onBatchEnd'];\n    const drawArea = render_utils_1.getDrawArea(container);\n    const historyOpts = Object.assign({}, opts);\n    delete historyOpts.callbacks;\n    function makeCallbackFor(callbackName) {\n        return (_, log) => __awaiter(this, void 0, void 0, function* () {\n            // Set a nicer x axis name where possible\n            if ((/batch/i).test(callbackName)) {\n                historyOpts.xLabel = 'Batch';\n            }\n            else if ((/epoch/i).test(callbackName)) {\n                historyOpts.xLabel = 'Epoch';\n            }\n            // Because of how the _ (iteration) numbers are given in the layers api\n            // we have to store each metric for each callback in different arrays else\n            // we cannot get accurate 'global' batch numbers for onBatchEnd.\n            // However at render time we want to be able to combine metrics for a\n            // given callback. So here we make a nested list of metrics, the first\n            // level are arrays for each callback, the second level contains arrays\n            // (of logs) for each metric within that callback.\n            const metricLogs = [];\n            const presentMetrics = [];\n            for (const metric of metrics) {\n                // not all logs have all kinds of metrics.\n                if (log[metric] != null) {\n                    presentMetrics.push(metric);\n                    const accumulator = getAccumulator(accumulators, callbackName, metric);\n                    accumulator.push({ [metric]: log[metric] });\n                    metricLogs.push(accumulator);\n                }\n            }\n            const subContainer = dom_1.subSurface(drawArea, callbackName, { title: callbackName });\n            history(subContainer, metricLogs, presentMetrics, historyOpts);\n            yield render_utils_1.nextFrame();\n        });\n    }\n    const callbacks = {};\n    callbackNames.forEach((name) => {\n        callbacks[name] = makeCallbackFor(name);\n    });\n    return callbacks;\n}\nexports.fitCallbacks = fitCallbacks;\nfunction getAccumulator(accumulators, callback, metric) {\n    if (accumulators[callback] == null) {\n        accumulators[callback] = {};\n    }\n    if (accumulators[callback][metric] == null) {\n        accumulators[callback][metric] = [];\n    }\n    return accumulators[callback][metric];\n}\n"},"sourceMaps":{"js":{"version":3,"file":"history.js","sourceRoot":"","sources":["../../src/show/history.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Logs} from '@tensorflow/tfjs-layers';\n\nimport {linechart} from '../render/linechart';\nimport {getDrawArea, nextFrame} from '../render/render_utils';\nimport {Drawable, Point2D, XYPlotOptions} from '../types';\nimport {subSurface} from '../util/dom';\n\n/**\n * Renders a tf.Model training 'History'.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32\n * });\n *\n * tfvis.show.history(surface, history, ['loss', 'acc']);\n * ```\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.history live', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * const history = [];\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: {\n *      onEpochEnd: (epoch, log) => {\n *        history.push(log);\n *        tfvis.show.history(surface, history, ['loss', 'acc']);\n *      }\n *    }\n * });\n * ```\n *\n * @param history A history like object. Either a tfjs-layers `History` object\n *  or an array of tfjs-layers `Logs` objects.\n * @param metrics An array of strings for each metric to plot from the history\n *  object. Using this allows you to control which metrics appear on the same\n *  plot.\n * @param opts Optional parameters for the line charts.\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nexport async function history(\n    container: Drawable, history: HistoryLike, metrics: string[],\n    opts: HistoryOptions = {}): Promise<void> {\n  // Get the draw surface\n  const drawArea = getDrawArea(container);\n\n  // We organize the data from the history object into discrete plot data\n  // objects so that we can group together appropriate metrics into single\n  // multi-series charts.\n  const plots: HistoryPlotData = {};\n  for (const metric of metrics) {\n    if (!(/val_/.test(metric))) {\n      // Non validation metric\n      const values = getValues(history, metric, metrics.indexOf(metric));\n      initPlot(plots, metric);\n      plots[metric].series.push(metric);\n      plots[metric].values.push(values);\n    } else {\n      // Validation metrics are grouped with their equivalent non validation\n      // metrics. Note that the corresponding non validation metric may not\n      // actually be included but we still want to use it as a plot name.\n      const nonValidationMetric = metric.replace('val_', '');\n      initPlot(plots, nonValidationMetric);\n      const values = getValues(history, metric, metrics.indexOf(metric));\n      plots[nonValidationMetric].series.push(metric);\n      plots[nonValidationMetric].values.push(values);\n    }\n  }\n\n  // Render each plot specified above to a new subsurface.\n  // A plot may have multiple series.\n  const plotNames = Object.keys(plots);\n  const options =\n      Object.assign({}, {xLabel: 'Iteration', yLabel: 'Value'}, opts);\n\n  const renderPromises = [];\n  for (const name of plotNames) {\n    const subContainer = subSurface(drawArea, name);\n    const series = plots[name].series;\n    const values = plots[name].values;\n\n    if (series.every(seriesName => Boolean(seriesName.match('acc')))) {\n      // Set a domain of 0-1 if all the series in this plot are related to\n      // accuracy. Can be overridden by setting zoomToFitAccuracy to true.\n      if (options.zoomToFitAccuracy) {\n        options.zoomToFit = true;\n      } else {\n        options.yAxisDomain = [0, 1];\n        delete options.zoomToFit;\n      }\n    }\n\n    const done = linechart(subContainer, {values, series}, options);\n    renderPromises.push(done);\n  }\n  await Promise.all(renderPromises);\n}\n\ninterface HistoryOptions extends XYPlotOptions {\n  zoomToFitAccuracy?: boolean;\n}\n\ntype HistoryLike = Logs[]|Logs[][]|{\n  history: {\n    [key: string]: number[],\n  }\n};\n\ninterface HistoryPlotData {\n  [name: string]: {\n    series: string[],\n    values: Point2D[][],\n  };\n}\n\nfunction initPlot(plot: HistoryPlotData, name: string) {\n  if (plot[name] == null) {\n    plot[name] = {series: [], values: []};\n  }\n}\n\n/*\n * Extracts a list of Point2D's suitable for plotting from a HistoryLike for\n * a single metric.\n * @param history a HistoryLike object\n * @param metric the metric to extract from the logs\n * @param metricIndex this is needed because the historylike can be a nested\n * list of logs for multiple metrics, this index lets us extract the correct\n * list.\n */\nfunction getValues(\n    history: HistoryLike, metric: string, metricIndex: number): Point2D[] {\n  if (Array.isArray(history)) {\n    // If we were passed a nested array we want to get the correct list\n    // for this given metric, metrix index gives us this list.\n    const metricHistory =\n        (Array.isArray(history[0]) ? history[metricIndex] : history) as Logs[];\n    const points: Point2D[] = [];\n\n    for (let i = 0; i < metricHistory.length; i++) {\n      const log = metricHistory[i];\n      points.push({x: i, y: log[metric]});\n    }\n    return points;\n  } else {\n    return history.history[metric].map((y, x) => ({x, y}));\n  }\n}\n\n/**\n * Returns a collection of callbacks to pass to tf.Model.fit. Callbacks are\n * returned for the following events, `onBatchEnd` & `onEpochEnd`.\n *\n * ```js\n * const model = tf.sequential({\n *  layers: [\n *    tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),\n *    tf.layers.dense({units: 10, activation: 'softmax'}),\n *  ]\n * });\n *\n * model.compile({\n *   optimizer: 'sgd',\n *   loss: 'categoricalCrossentropy',\n *   metrics: ['accuracy']\n * });\n *\n * const data = tf.randomNormal([100, 784]);\n * const labels = tf.randomUniform([100, 10]);\n *\n * function onBatchEnd(batch, logs) {\n *   console.log('Accuracy', logs.acc);\n * }\n *\n * const surface = { name: 'show.fitCallbacks', tab: 'Training' };\n * // Train for 5 epochs with batch size of 32.\n * await model.fit(data, labels, {\n *    epochs: 5,\n *    batchSize: 32,\n *    callbacks: tfvis.show.fitCallbacks(surface, ['loss', 'acc']),\n * });\n * ```\n *\n * @param metrics List of metrics to plot.\n * @param opts Optional parameters\n */\n/**\n * @doc {heading: 'Models & Tensors', subheading: 'Model Training', namespace:\n * 'show'}\n */\nexport function fitCallbacks(\n    container: Drawable, metrics: string[],\n    opts: FitCallbackOptions = {}): FitCallbackHandlers {\n  const accumulators: FitCallbackLogs = {};\n  const callbackNames = opts.callbacks || ['onEpochEnd', 'onBatchEnd'];\n  const drawArea = getDrawArea(container);\n\n  const historyOpts = Object.assign({}, opts);\n  delete historyOpts.callbacks;\n  function makeCallbackFor(callbackName: string) {\n    return async (_: number, log: Logs) => {\n      // Set a nicer x axis name where possible\n      if ((/batch/i).test(callbackName)) {\n        historyOpts.xLabel = 'Batch';\n      } else if ((/epoch/i).test(callbackName)) {\n        historyOpts.xLabel = 'Epoch';\n      }\n\n      // Because of how the _ (iteration) numbers are given in the layers api\n      // we have to store each metric for each callback in different arrays else\n      // we cannot get accurate 'global' batch numbers for onBatchEnd.\n\n      // However at render time we want to be able to combine metrics for a\n      // given callback. So here we make a nested list of metrics, the first\n      // level are arrays for each callback, the second level contains arrays\n      // (of logs) for each metric within that callback.\n\n      const metricLogs: Logs[][] = [];\n      const presentMetrics: string[] = [];\n      for (const metric of metrics) {\n        // not all logs have all kinds of metrics.\n        if (log[metric] != null) {\n          presentMetrics.push(metric);\n\n          const accumulator =\n              getAccumulator(accumulators, callbackName, metric);\n          accumulator.push({[metric]: log[metric]});\n          metricLogs.push(accumulator);\n        }\n      }\n\n      const subContainer =\n          subSurface(drawArea, callbackName, {title: callbackName});\n      history(subContainer, metricLogs, presentMetrics, historyOpts);\n      await nextFrame();\n    };\n  }\n\n  const callbacks: FitCallbackHandlers = {};\n  callbackNames.forEach((name: string) => {\n    callbacks[name] = makeCallbackFor(name);\n  });\n  return callbacks;\n}\n\ninterface FitCallbackHandlers {\n  [key: string]: (iteration: number, log: Logs) => Promise<void>;\n}\n\ninterface FitCallbackLogs {\n  [callback: string]: {\n    [metric: string]: Logs[],\n  };\n}\n\ninterface FitCallbackOptions extends HistoryOptions {\n  /**\n   * Array of callback names. Valid options\n   * are 'onEpochEnd' and 'onBatchEnd'. Defaults to ['onEpochEnd',\n   * 'onBatchEnd'].\n   */\n  callbacks?: string[];\n}\n\nfunction getAccumulator(\n    accumulators: FitCallbackLogs, callback: string, metric: string): Logs[] {\n  if (accumulators[callback] == null) {\n    accumulators[callback] = {};\n  }\n  if (accumulators[callback][metric] == null) {\n    accumulators[callback][metric] = [];\n  }\n  return accumulators[callback][metric];\n}\n"]}},"error":null,"hash":"4ac7b91cfe60c553a09ef32b543435f5","cacheData":{"env":{}}}