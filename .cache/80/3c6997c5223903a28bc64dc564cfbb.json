{"id":"../node_modules/@tensorflow/tfjs-vis/dist/util/math.js","dependencies":[{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\math.js.map","includedInParent":true,"mtime":1595569813578},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\package.json","includedInParent":true,"mtime":1595925880834},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\package.json","includedInParent":true,"mtime":1595569813578},{"name":"@tensorflow/tfjs","loc":{"line":27,"column":23},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\math.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs\\dist\\index.js"},{"name":"./utils","loc":{"line":28,"column":24},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\math.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tfjs_1 = require(\"@tensorflow/tfjs\");\nconst utils_1 = require(\"./utils\");\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\nfunction arrayStats(input) {\n    if (!Array.isArray(input)) {\n        throw new Error('input must be an array');\n    }\n    if (input.length === 0) {\n        return {\n            numVals: 0,\n            numNans: 0,\n            numZeros: 0,\n            max: undefined,\n            min: undefined,\n        };\n    }\n    const numVals = input.length;\n    let max = -Infinity;\n    let min = Infinity;\n    let numZeros = 0;\n    let numNans = 0;\n    let numInfs = 0;\n    for (let i = 0; i < numVals; i++) {\n        const curr = input[i];\n        if (curr > max) {\n            max = curr;\n        }\n        if (curr < min) {\n            min = curr;\n        }\n        if (curr === 0) {\n            numZeros += 1;\n        }\n        if (isNaN(curr)) {\n            numNans += 1;\n        }\n        else if (!isFinite(curr)) {\n            // Make sure NaNs are not double counted as Infs\n            numInfs += 1;\n        }\n    }\n    const result = {\n        numVals,\n        numZeros,\n        numNans,\n        max,\n        min,\n        numInfs,\n    };\n    // Handle all NaN input\n    if (result.max === -Infinity) {\n        result.max = NaN;\n    }\n    if (result.min === Infinity) {\n        result.min = NaN;\n    }\n    return result;\n}\nexports.arrayStats = arrayStats;\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\nfunction tensorStats(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // TODO. Benchmark this and consider having one of the *stats functions\n        // delegate to the other.\n        const [min, max, numZeros] = tfjs_1.tidy(() => {\n            const zero = tfjs_1.scalar(0, input.dtype);\n            const min = input.min();\n            const max = input.max();\n            const numZeros = input.equal(zero).sum();\n            return [min, max, numZeros];\n        });\n        return Promise\n            .all([input.data(), min.data(), max.data(), numZeros.data()])\n            .then(([tensorVal, minVal, maxVal, numZerosVal]) => {\n            // We currently need to count NaNs on CPU.\n            const numVals = tensorVal.length;\n            let numNans = 0;\n            let numInfs = 0;\n            for (let i = 0; i < numVals; i++) {\n                const curr = tensorVal[i];\n                if (isNaN(curr)) {\n                    numNans += 1;\n                }\n                else if (!isFinite(curr)) {\n                    // Make sure NaNs are not double counted as Infs\n                    numInfs += 1;\n                }\n            }\n            let trueMin = minVal[0];\n            let trueMax = maxVal[0];\n            if (numNans === numVals) {\n                // on gpu the min and max won't be accurate if all values are NaN\n                trueMin = NaN;\n                trueMax = NaN;\n            }\n            const stats = {\n                numVals,\n                numZeros: numZerosVal[0],\n                numNans,\n                min: trueMin,\n                max: trueMax,\n                numInfs,\n            };\n            return stats;\n        });\n    });\n}\nexports.tensorStats = tensorStats;\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nfunction confusionMatrix(labels, predictions, numClasses, weights) {\n    return __awaiter(this, void 0, void 0, function* () {\n        utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n        utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n        utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n        if (weights != null) {\n            utils_1.assert(weights.size === predictions.size, 'labels and predictions must be the same length');\n        }\n        // Cast to int in case the caller didn't\n        const labelsInt = labels.cast('int32');\n        const predictionsInt = predictions.cast('int32');\n        if (numClasses == null) {\n            numClasses =\n                tfjs_1.tidy(() => {\n                    const max = tfjs_1.maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n                    return max.dataSync()[0] + 1;\n                });\n        }\n        let weightsPromise = Promise.resolve(null);\n        if (weights != null) {\n            weightsPromise = weights.data();\n        }\n        return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise])\n            .then(([labelsArray, predsArray, weightsArray]) => {\n            const result = Array(numClasses).fill(0);\n            // Initialize the matrix\n            for (let i = 0; i < numClasses; i++) {\n                result[i] = Array(numClasses).fill(0);\n            }\n            for (let i = 0; i < labelsArray.length; i++) {\n                const label = labelsArray[i];\n                const pred = predsArray[i];\n                if (weightsArray != null) {\n                    result[label][pred] += weightsArray[i];\n                }\n                else {\n                    result[label][pred] += 1;\n                }\n            }\n            return result;\n        });\n    });\n}\nexports.confusionMatrix = confusionMatrix;\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nfunction accuracy(labels, predictions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        utils_1.assertShapesMatch(labels.shape, predictions.shape, 'Error computing accuracy.');\n        const eq = labels.equal(predictions);\n        const mean = eq.mean();\n        const acc = (yield mean.data())[0];\n        tfjs_1.dispose([eq, mean]);\n        return acc;\n    });\n}\nexports.accuracy = accuracy;\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nfunction perClassAccuracy(labels, predictions, numClasses) {\n    return __awaiter(this, void 0, void 0, function* () {\n        utils_1.assert(labels.rank === 1, 'labels must be a 1D tensor');\n        utils_1.assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n        utils_1.assert(labels.size === predictions.size, 'labels and predictions must be the same length');\n        if (numClasses == null) {\n            numClasses = tfjs_1.tidy(() => {\n                return tfjs_1.maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n            });\n        }\n        return Promise.all([labels.data(), predictions.data()])\n            .then(([labelsArray, predsArray]) => {\n            // Per class total counts\n            const counts = Array(numClasses).fill(0);\n            // Per class accuracy\n            const accuracy = Array(numClasses).fill(0);\n            for (let i = 0; i < labelsArray.length; i++) {\n                const label = labelsArray[i];\n                const pred = predsArray[i];\n                counts[label] += 1;\n                if (label === pred) {\n                    accuracy[label] += 1;\n                }\n            }\n            const results = [];\n            for (let i = 0; i < counts.length; i++) {\n                results.push({\n                    count: counts[i],\n                    accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i],\n                });\n            }\n            return results;\n        });\n    });\n}\nexports.perClassAccuracy = perClassAccuracy;\n"},"sourceMaps":{"js":{"version":3,"file":"math.js","sourceRoot":"","sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {dispose, maximum, scalar, Tensor, Tensor1D, tidy} from '@tensorflow/tfjs';\n\nimport {HistogramStats, TypedArray} from '../types';\n\nimport {assert, assertShapesMatch} from './utils';\n\n/**\n * Returns summary statistics for an array of numbers\n *\n * @param input\n */\nexport function arrayStats(input: number[]): HistogramStats {\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n  if (input.length === 0) {\n    return {\n      numVals: 0,\n      numNans: 0,\n      numZeros: 0,\n      max: undefined,\n      min: undefined,\n    };\n  }\n\n  const numVals = input.length;\n  let max = -Infinity;\n  let min = Infinity;\n  let numZeros = 0;\n  let numNans = 0;\n  let numInfs = 0;\n\n  for (let i = 0; i < numVals; i++) {\n    const curr = input[i];\n    if (curr > max) {\n      max = curr;\n    }\n\n    if (curr < min) {\n      min = curr;\n    }\n\n    if (curr === 0) {\n      numZeros += 1;\n    }\n\n    if (isNaN(curr)) {\n      numNans += 1;\n    } else if (!isFinite(curr)) {\n      // Make sure NaNs are not double counted as Infs\n      numInfs += 1;\n    }\n  }\n\n  const result = {\n    numVals,\n    numZeros,\n    numNans,\n    max,\n    min,\n    numInfs,\n  };\n\n  // Handle all NaN input\n  if (result.max === -Infinity) {\n    result.max = NaN;\n  }\n  if (result.min === Infinity) {\n    result.min = NaN;\n  }\n\n  return result;\n}\n\n/**\n * Returns summary statistics for a numeric tensor. *\n *\n * @param input\n */\nexport async function tensorStats(input: Tensor): Promise<HistogramStats> {\n  // TODO. Benchmark this and consider having one of the *stats functions\n  // delegate to the other.\n\n  const [min, max, numZeros] = tidy(() => {\n    const zero = scalar(0, input.dtype);\n\n    const min = input.min();\n    const max = input.max();\n    const numZeros = input.equal(zero).sum();\n\n    return [min, max, numZeros];\n  });\n\n  return Promise\n      .all([input.data(), min.data(), max.data(), numZeros.data()])\n      .then(([tensorVal, minVal, maxVal, numZerosVal]) => {\n        // We currently need to count NaNs on CPU.\n        const numVals = tensorVal.length;\n        let numNans = 0;\n        let numInfs = 0;\n        for (let i = 0; i < numVals; i++) {\n          const curr = tensorVal[i];\n          if (isNaN(curr)) {\n            numNans += 1;\n          } else if (!isFinite(curr)) {\n            // Make sure NaNs are not double counted as Infs\n            numInfs += 1;\n          }\n        }\n\n        let trueMin = minVal[0];\n        let trueMax = maxVal[0];\n        if (numNans === numVals) {\n          // on gpu the min and max won't be accurate if all values are NaN\n          trueMin = NaN;\n          trueMax = NaN;\n        }\n\n        const stats = {\n          numVals,\n          numZeros: numZerosVal[0],\n          numNans,\n          min: trueMin,\n          max: trueMax,\n          numInfs,\n        };\n\n        return stats;\n      });\n}\n\n/**\n * Computes a confusion matrix from predictions and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([1, 2, 4]);\n * const predictions = tf.tensor1d([2, 2, 4]);\n * const result = await tfvis.metrics.confusionMatrix(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n * @param weights 1d tensor that is the same size as predictions.\n *  If weights is passed in then each prediction contributes its corresponding\n *  weight to the total value of the confusion matrix cell.\n *\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function confusionMatrix(\n    labels: Tensor1D, predictions: Tensor1D, numClasses?: number,\n    weights?: Tensor1D): Promise<number[][]> {\n  assert(labels.rank === 1, 'labels must be a 1D tensor');\n  assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n  assert(\n      labels.size === predictions.size,\n      'labels and predictions must be the same length');\n  if (weights != null) {\n    assert(\n        weights.size === predictions.size,\n        'labels and predictions must be the same length');\n  }\n\n  // Cast to int in case the caller didn't\n  const labelsInt = labels.cast('int32');\n  const predictionsInt = predictions.cast('int32');\n\n  if (numClasses == null) {\n    numClasses =\n        tidy(() => {\n          const max =\n              maximum(labelsInt.max(), predictionsInt.max()).cast('int32');\n          return max.dataSync()[0] + 1;\n        });\n  }\n\n  let weightsPromise: Promise<null|TypedArray> = Promise.resolve(null);\n  if (weights != null) {\n    weightsPromise = weights.data();\n  }\n\n  return Promise.all([labelsInt.data(), predictionsInt.data(), weightsPromise])\n      .then(([labelsArray, predsArray, weightsArray]) => {\n        const result: number[][] = Array(numClasses).fill(0);\n        // Initialize the matrix\n        for (let i = 0; i < numClasses; i++) {\n          result[i] = Array(numClasses).fill(0);\n        }\n\n        for (let i = 0; i < labelsArray.length; i++) {\n          const label = labelsArray[i];\n          const pred = predsArray[i];\n\n          if (weightsArray != null) {\n            result[label][pred] += weightsArray[i];\n          } else {\n            result[label][pred] += 1;\n          }\n        }\n\n        return result;\n      });\n}\n\n/**\n * Computes how often predictions matches labels\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.accuracy(labels, predictions);\n * console.log(result)\n * ```\n *\n * @param labels tensor of true values\n * @param predictions tensor of predicted values\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function accuracy(\n    labels: Tensor, predictions: Tensor): Promise<number> {\n  assertShapesMatch(\n      labels.shape, predictions.shape, 'Error computing accuracy.');\n\n  const eq = labels.equal(predictions);\n  const mean = eq.mean();\n\n  const acc = (await mean.data())[0];\n\n  dispose([eq, mean]);\n  return acc;\n}\n\n/**\n * Computes per class accuracy between prediction and labels. Each value in\n * labels and predictions should correspond to some output class. It is assumed\n * that these values go from 0 to numClasses - 1.\n *\n * ```js\n * const labels = tf.tensor1d([0, 0, 1, 2, 2, 2]);\n * const predictions = tf.tensor1d([0, 0, 0, 2, 1, 1]);\n *\n * const result = await tfvis.metrics.perClassAccuracy(labels, predictions);\n * console.log(JSON.stringify(result, null, 2))\n * ```\n *\n * Returns an array of objects that each have an an `accuracy` and a `count`\n * property for each class.\n *\n *\n * @param labels 1D tensor of true values\n * @param predictions 1D tensor of predicted values\n * @param numClasses Number of distinct classes. Optional. If not passed in\n *  numClasses will equal the highest number in either labels or predictions\n *  plus 1\n */\n/**\n * @doc {heading: 'Metrics', namespace: 'metrics'}\n */\nexport async function perClassAccuracy(\n    labels: Tensor1D, predictions: Tensor1D,\n    numClasses?: number): Promise<Array<{accuracy: number, count: number}>> {\n  assert(labels.rank === 1, 'labels must be a 1D tensor');\n  assert(predictions.rank === 1, 'predictions must be a 1D tensor');\n  assert(\n      labels.size === predictions.size,\n      'labels and predictions must be the same length');\n\n  if (numClasses == null) {\n    numClasses = tidy(() => {\n      return maximum(labels.max(), predictions.max()).dataSync()[0] + 1;\n    });\n  }\n\n  return Promise.all([labels.data(), predictions.data()])\n      .then(([labelsArray, predsArray]) => {\n        // Per class total counts\n        const counts: number[] = Array(numClasses).fill(0);\n        // Per class accuracy\n        const accuracy: number[] = Array(numClasses).fill(0);\n\n        for (let i = 0; i < labelsArray.length; i++) {\n          const label = labelsArray[i];\n          const pred = predsArray[i];\n\n          counts[label] += 1;\n          if (label === pred) {\n            accuracy[label] += 1;\n          }\n        }\n\n        const results: Array<{accuracy: number, count: number}> = [];\n        for (let i = 0; i < counts.length; i++) {\n          results.push({\n            count: counts[i],\n            accuracy: counts[i] === 0 ? 0 : accuracy[i] / counts[i],\n          });\n        }\n\n        return results;\n      });\n}\n"]}},"error":null,"hash":"c0f092b1aa0beb84ff07a6ae5f4303dd","cacheData":{"env":{}}}