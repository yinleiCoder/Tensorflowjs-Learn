{"id":"../node_modules/@tensorflow/tfjs-vis/dist/render/heatmap.js","dependencies":[{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js.map","includedInParent":true,"mtime":1595569813578},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\package.json","includedInParent":true,"mtime":1595925880834},{"name":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\package.json","includedInParent":true,"mtime":1595569813578},{"name":"@tensorflow/tfjs","loc":{"line":37,"column":32},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs\\dist\\index.js"},{"name":"vega-embed","loc":{"line":38,"column":45},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\vega-embed\\build\\src\\embed.js"},{"name":"../util/dom","loc":{"line":39,"column":22},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\dom.js"},{"name":"../util/utils","loc":{"line":40,"column":24},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\util\\utils.js"},{"name":"./render_utils","loc":{"line":41,"column":31},"parent":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\heatmap.js","resolved":"E:\\VisualStudioCodeProjects\\js机器学习\\node_modules\\@tensorflow\\tfjs-vis\\dist\\render\\render_utils.js"}],"generated":{"js":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tf = __importStar(require(\"@tensorflow/tfjs\"));\nconst vega_embed_1 = __importDefault(require(\"vega-embed\"));\nconst dom_1 = require(\"../util/dom\");\nconst utils_1 = require(\"../util/utils\");\nconst render_utils_1 = require(\"./render_utils\");\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nfunction heatmap(container, data, opts = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const options = Object.assign({}, defaultOpts, opts);\n        const drawArea = render_utils_1.getDrawArea(container);\n        let inputValues = data.values;\n        if (options.rowMajor) {\n            inputValues = yield convertToRowMajor(data.values);\n        }\n        // Data validation\n        const { xTickLabels, yTickLabels } = data;\n        if (xTickLabels != null) {\n            const dimension = 0;\n            assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n        }\n        // Note that we will only do a check on the first element of the second\n        // dimension. We do not protect users against passing in a ragged array.\n        if (yTickLabels != null) {\n            const dimension = 1;\n            assertLabelsMatchShape(inputValues, yTickLabels, dimension);\n        }\n        //\n        // Format data for vega spec; an array of objects, one for for each cell\n        // in the matrix.\n        //\n        // If custom labels are passed in for xTickLabels or yTickLabels we need\n        // to make sure they are 'unique' before mapping them to visual properties.\n        // We therefore append the index of the label to the datum that will be used\n        // for that label in the x or y axis. We could do this in all cases but choose\n        // not to to avoid unnecessary string operations.\n        //\n        // We use IDX_SEPARATOR to demarcate the added index\n        const IDX_SEPARATOR = '@tfidx@';\n        const values = [];\n        if (inputValues instanceof tf.Tensor) {\n            utils_1.assert(inputValues.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d');\n            // This is a slightly specialized version of TensorBuffer.get, inlining it\n            // avoids the overhead of a function call per data element access and is\n            // specialized to only deal with the 2d case.\n            const inputArray = yield inputValues.data();\n            const [numRows, numCols] = inputValues.shape;\n            for (let row = 0; row < numRows; row++) {\n                const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n                for (let col = 0; col < numCols; col++) {\n                    const y = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n                    const index = (row * numCols) + col;\n                    const value = inputArray[index];\n                    values.push({ x, y, value });\n                }\n            }\n        }\n        else {\n            const inputArray = inputValues;\n            for (let row = 0; row < inputArray.length; row++) {\n                const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n                for (let col = 0; col < inputArray[row].length; col++) {\n                    const y = yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n                    const value = inputArray[row][col];\n                    values.push({ x, y, value });\n                }\n            }\n        }\n        const embedOpts = {\n            actions: false,\n            mode: 'vega-lite',\n            defaultStyle: false,\n        };\n        const spec = {\n            'width': options.width || dom_1.getDefaultWidth(drawArea),\n            'height': options.height || dom_1.getDefaultHeight(drawArea),\n            'padding': 0,\n            'autosize': {\n                'type': 'fit',\n                'contains': 'padding',\n                'resize': true,\n            },\n            'config': {\n                'axis': {\n                    'labelFontSize': options.fontSize,\n                    'titleFontSize': options.fontSize,\n                },\n                'text': { 'fontSize': options.fontSize },\n                'legend': {\n                    'labelFontSize': options.fontSize,\n                    'titleFontSize': options.fontSize,\n                },\n                'scale': { 'bandPaddingInner': 0, 'bandPaddingOuter': 0 },\n            },\n            //@ts-ignore\n            'data': { 'values': values },\n            'mark': { 'type': 'rect', 'tooltip': true },\n            'encoding': {\n                'x': {\n                    'field': 'x',\n                    'type': options.xType,\n                    'title': options.xLabel,\n                    'sort': 'x',\n                },\n                'y': {\n                    'field': 'y',\n                    'type': options.yType,\n                    'title': options.yLabel,\n                    'sort': 'y',\n                },\n                'fill': {\n                    'field': 'value',\n                    'type': 'quantitative',\n                }\n            }\n        };\n        //\n        // Format custom labels to remove the appended indices\n        //\n        const suffixPattern = `${IDX_SEPARATOR}\\\\d+$`;\n        const suffixRegex = new RegExp(suffixPattern);\n        if (xTickLabels) {\n            // @ts-ignore\n            spec.encoding.x.axis = {\n                'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n            };\n        }\n        if (yTickLabels) {\n            // @ts-ignore\n            spec.encoding.y.axis = {\n                'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n            };\n        }\n        // Customize tooltip formatting to remove the appended indices\n        if (xTickLabels || yTickLabels) {\n            //@ts-ignore\n            embedOpts.tooltip = {\n                sanitize: (value) => {\n                    const valueString = String(value);\n                    return valueString.replace(suffixRegex, '');\n                }\n            };\n        }\n        let colorRange;\n        switch (options.colorMap) {\n            case 'blues':\n                colorRange = ['#f7fbff', '#4292c6'];\n                break;\n            case 'greyscale':\n                colorRange = ['#000000', '#ffffff'];\n                break;\n            case 'viridis':\n            default:\n                colorRange = 'viridis';\n                break;\n        }\n        if (colorRange !== 'viridis') {\n            //@ts-ignore\n            const fill = spec.encoding.fill;\n            // @ts-ignore\n            fill.scale = { 'range': colorRange };\n        }\n        if (options.domain) {\n            //@ts-ignore\n            const fill = spec.encoding.fill;\n            // @ts-ignore\n            if (fill.scale != null) {\n                // @ts-ignore\n                fill.scale = Object.assign({}, fill.scale, { 'domain': options.domain });\n            }\n            else {\n                // @ts-ignore\n                fill.scale = { 'domain': options.domain };\n            }\n        }\n        yield vega_embed_1.default(drawArea, spec, embedOpts);\n    });\n}\nexports.heatmap = heatmap;\nfunction convertToRowMajor(inputValues) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let originalShape;\n        let transposed;\n        if (inputValues instanceof tf.Tensor) {\n            originalShape = inputValues.shape;\n            transposed = inputValues.transpose();\n        }\n        else {\n            originalShape = [inputValues.length, inputValues[0].length];\n            transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());\n        }\n        utils_1.assert(transposed.rank === 2, 'Input to renderHeatmap must be a 2d array or Tensor2d');\n        // Download the intermediate tensor values and\n        // dispose the transposed tensor.\n        const transposedValues = yield transposed.array();\n        transposed.dispose();\n        const transposedShape = [transposedValues.length, transposedValues[0].length];\n        utils_1.assert(originalShape[0] === transposedShape[1] &&\n            originalShape[1] === transposedShape[0], `Unexpected transposed shape. Original ${originalShape} : Transposed ${transposedShape}`);\n        return transposedValues;\n    });\n}\nfunction assertLabelsMatchShape(inputValues, labels, dimension) {\n    const shape = inputValues instanceof tf.Tensor ?\n        inputValues.shape :\n        [inputValues.length, inputValues[0].length];\n    if (dimension === 0) {\n        utils_1.assert(shape[0] === labels.length, `Length of xTickLabels (${labels.length}) must match number of rows` +\n            ` (${shape[0]})`);\n    }\n    else if (dimension === 1) {\n        utils_1.assert(shape[1] === labels.length, `Length of yTickLabels (${labels.length}) must match number of columns (${shape[1]})`);\n    }\n}\nconst defaultOpts = {\n    xLabel: null,\n    yLabel: null,\n    xType: 'ordinal',\n    yType: 'ordinal',\n    colorMap: 'viridis',\n    fontSize: 12,\n    domain: null,\n    rowMajor: false,\n};\n"},"sourceMaps":{"js":{"version":3,"file":"heatmap.js","sourceRoot":"","sources":["../../src/render/heatmap.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport embed, {Mode, VisualizationSpec} from 'vega-embed';\n\nimport {Drawable, HeatmapData, HeatmapOptions} from '../types';\nimport {getDefaultHeight, getDefaultWidth} from '../util/dom';\nimport {assert} from '../util/utils';\n\nimport {getDrawArea} from './render_utils';\n\n/**\n * Renders a heatmap.\n *\n * ```js\n * const cols = 50;\n * const rows = 20;\n * const values = [];\n * for (let i = 0; i < cols; i++) {\n *   const col = []\n *   for (let j = 0; j < rows; j++) {\n *     col.push(i * j)\n *   }\n *   values.push(col);\n * }\n * const data = { values };\n *\n * // Render to visor\n * const surface = { name: 'Heatmap', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n * ```js\n * const data = {\n *   values: [[4, 2, 8, 20], [1, 7, 2, 10], [3, 3, 20, 13]],\n *   xTickLabels: ['cheese', 'pig', 'font'],\n *   yTickLabels: ['speed', 'smoothness', 'dexterity', 'mana'],\n * }\n *\n * // Render to visor\n * const surface = { name: 'Heatmap w Custom Labels', tab: 'Charts' };\n * tfvis.render.heatmap(surface, data);\n * ```\n *\n */\n/** @doc {heading: 'Charts', namespace: 'render'} */\nexport async function heatmap(\n    container: Drawable, data: HeatmapData,\n    opts: HeatmapOptions = {}): Promise<void> {\n  const options = Object.assign({}, defaultOpts, opts);\n  const drawArea = getDrawArea(container);\n\n  let inputValues = data.values;\n  if (options.rowMajor) {\n    inputValues = await convertToRowMajor(data.values);\n  }\n\n  // Data validation\n  const {xTickLabels, yTickLabels} = data;\n  if (xTickLabels != null) {\n    const dimension = 0;\n    assertLabelsMatchShape(inputValues, xTickLabels, dimension);\n  }\n\n  // Note that we will only do a check on the first element of the second\n  // dimension. We do not protect users against passing in a ragged array.\n  if (yTickLabels != null) {\n    const dimension = 1;\n    assertLabelsMatchShape(inputValues, yTickLabels, dimension);\n  }\n\n  //\n  // Format data for vega spec; an array of objects, one for for each cell\n  // in the matrix.\n  //\n  // If custom labels are passed in for xTickLabels or yTickLabels we need\n  // to make sure they are 'unique' before mapping them to visual properties.\n  // We therefore append the index of the label to the datum that will be used\n  // for that label in the x or y axis. We could do this in all cases but choose\n  // not to to avoid unnecessary string operations.\n  //\n  // We use IDX_SEPARATOR to demarcate the added index\n  const IDX_SEPARATOR = '@tfidx@';\n\n  const values: MatrixEntry[] = [];\n  if (inputValues instanceof tf.Tensor) {\n    assert(\n        inputValues.rank === 2,\n        'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n    // This is a slightly specialized version of TensorBuffer.get, inlining it\n    // avoids the overhead of a function call per data element access and is\n    // specialized to only deal with the 2d case.\n    const inputArray = await inputValues.data();\n    const [numRows, numCols] = inputValues.shape;\n\n    for (let row = 0; row < numRows; row++) {\n      const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n      for (let col = 0; col < numCols; col++) {\n        const y =\n            yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n\n        const index = (row * numCols) + col;\n        const value = inputArray[index];\n\n        values.push({x, y, value});\n      }\n    }\n  } else {\n    const inputArray = inputValues;\n    for (let row = 0; row < inputArray.length; row++) {\n      const x = xTickLabels ? `${xTickLabels[row]}${IDX_SEPARATOR}${row}` : row;\n      for (let col = 0; col < inputArray[row].length; col++) {\n        const y =\n            yTickLabels ? `${yTickLabels[col]}${IDX_SEPARATOR}${col}` : col;\n        const value = inputArray[row][col];\n        values.push({x, y, value});\n      }\n    }\n  }\n\n  const embedOpts = {\n    actions: false,\n    mode: 'vega-lite' as Mode,\n    defaultStyle: false,\n  };\n\n  const spec: VisualizationSpec = {\n    'width': options.width || getDefaultWidth(drawArea),\n    'height': options.height || getDefaultHeight(drawArea),\n    'padding': 0,\n    'autosize': {\n      'type': 'fit',\n      'contains': 'padding',\n      'resize': true,\n    },\n    'config': {\n      'axis': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'text': {'fontSize': options.fontSize},\n      'legend': {\n        'labelFontSize': options.fontSize,\n        'titleFontSize': options.fontSize,\n      },\n      'scale': {'bandPaddingInner': 0, 'bandPaddingOuter': 0},\n    },\n    //@ts-ignore\n    'data': {'values': values},\n    'mark': {'type': 'rect', 'tooltip': true},\n    'encoding': {\n      'x': {\n        'field': 'x',\n        'type': options.xType,\n        'title': options.xLabel,\n        'sort': 'x',\n      },\n      'y': {\n        'field': 'y',\n        'type': options.yType,\n        'title': options.yLabel,\n        'sort': 'y',\n      },\n      'fill': {\n        'field': 'value',\n        'type': 'quantitative',\n      }\n    }\n  };\n\n  //\n  // Format custom labels to remove the appended indices\n  //\n  const suffixPattern = `${IDX_SEPARATOR}\\\\d+$`;\n  const suffixRegex = new RegExp(suffixPattern);\n  if (xTickLabels) {\n    // @ts-ignore\n    spec.encoding.x.axis = {\n      'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n    };\n  }\n\n  if (yTickLabels) {\n    // @ts-ignore\n    spec.encoding.y.axis = {\n      'labelExpr': `replace(datum.value, regexp(/${suffixPattern}/), '')`,\n    };\n  }\n\n  // Customize tooltip formatting to remove the appended indices\n  if (xTickLabels || yTickLabels) {\n    //@ts-ignore\n    embedOpts.tooltip = {\n      sanitize: (value: string|number) => {\n        const valueString = String(value);\n        return valueString.replace(suffixRegex, '');\n      }\n    };\n  }\n\n  let colorRange: string[]|string;\n  switch (options.colorMap) {\n    case 'blues':\n      colorRange = ['#f7fbff', '#4292c6'];\n      break;\n    case 'greyscale':\n      colorRange = ['#000000', '#ffffff'];\n      break;\n    case 'viridis':\n    default:\n      colorRange = 'viridis';\n      break;\n  }\n\n  if (colorRange !== 'viridis') {\n    //@ts-ignore\n    const fill = spec.encoding.fill;\n    // @ts-ignore\n    fill.scale = {'range': colorRange};\n  }\n\n  if (options.domain) {\n    //@ts-ignore\n    const fill = spec.encoding.fill;\n    // @ts-ignore\n    if (fill.scale != null) {\n      // @ts-ignore\n      fill.scale = Object.assign({}, fill.scale, {'domain': options.domain});\n    } else {\n      // @ts-ignore\n      fill.scale = {'domain': options.domain};\n    }\n  }\n\n  await embed(drawArea, spec, embedOpts);\n}\n\nasync function convertToRowMajor(inputValues: number[][]|\n                                 tf.Tensor2D): Promise<number[][]> {\n  let originalShape: number[];\n  let transposed: tf.Tensor2D;\n  if (inputValues instanceof tf.Tensor) {\n    originalShape = inputValues.shape;\n    transposed = inputValues.transpose();\n  } else {\n    originalShape = [inputValues.length, inputValues[0].length];\n    transposed = tf.tidy(() => tf.tensor2d(inputValues).transpose());\n  }\n\n  assert(\n      transposed.rank === 2,\n      'Input to renderHeatmap must be a 2d array or Tensor2d');\n\n  // Download the intermediate tensor values and\n  // dispose the transposed tensor.\n  const transposedValues = await transposed.array();\n  transposed.dispose();\n\n  const transposedShape = [transposedValues.length, transposedValues[0].length];\n  assert(\n      originalShape[0] === transposedShape[1] &&\n          originalShape[1] === transposedShape[0],\n      `Unexpected transposed shape. Original ${originalShape} : Transposed ${\n          transposedShape}`);\n  return transposedValues;\n}\n\nfunction assertLabelsMatchShape(\n    inputValues: number[][]|tf.Tensor2D, labels: string[], dimension: 0|1) {\n  const shape = inputValues instanceof tf.Tensor ?\n      inputValues.shape :\n      [inputValues.length, inputValues[0].length];\n  if (dimension === 0) {\n    assert(\n        shape[0] === labels.length,\n        `Length of xTickLabels (${labels.length}) must match number of rows` +\n            ` (${shape[0]})`);\n  } else if (dimension === 1) {\n    assert(\n        shape[1] === labels.length,\n        `Length of yTickLabels (${\n            labels.length}) must match number of columns (${shape[1]})`);\n  }\n}\n\nconst defaultOpts: HeatmapOptions = {\n  xLabel: null,\n  yLabel: null,\n  xType: 'ordinal',\n  yType: 'ordinal',\n  colorMap: 'viridis',\n  fontSize: 12,\n  domain: null,\n  rowMajor: false,\n};\n\ninterface MatrixEntry {\n  x: string|number;\n  y: string|number;\n  value: number;\n}\n"]}},"error":null,"hash":"5aa320c65f1eeb72bf1b1c4e597d7e33","cacheData":{"env":{}}}